'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toBePresent = toBePresent;
exports.toBeChecked = toBeChecked;
exports.toBeEditable = toBeEditable;
exports.toHaveSelectedValue = toHaveSelectedValue;
exports.toHaveValue = toHaveValue;
exports.toHaveText = toHaveText;

var _utils = require('./utils');

async function toBePresent(received) {
  try {
    const elements = await received;
    // undefined means the elements is not located, isWebElement will throw, so we can't reach it
    if (!received || Array.isArray(elements) && !elements[0]) {
      return {
        message: () => 'Assetion failed: expected element was not found in page',
        pass: false
      };
    } else if ((0, _utils.isWebElement)(Array.isArray(elements) ? elements[0] : elements)) {
      return {
        message: () => 'Assertion failed: unexpected element was found in page',
        pass: true
      };
    }
  } catch (err) {
    return {
      message: () => err.message,
      pass: this.isNot
    };
  }
}

async function toBeChecked(received) {
  try {
    return (0, _utils.isWebElement)(received) && (await received.isSelected()) ? {
      message: () => 'Assertion failed: element is checked',
      pass: true
    } : {
      message: () => 'Assetion failed: element is not checked',
      pass: false
    };
  } catch (err) {
    return {
      message: () => err.message,
      pass: this.isNot
    };
  }
}

async function toBeEditable(received) {
  try {
    return (0, _utils.isWebElement)(received) && (await received.isEnabled()) && !(await received.getAttribute('readonly')) ? {
      message: () => 'Assertion failed: element is editable',
      pass: true
    } : {
      message: () => 'Assetion failed: element is not editable',
      pass: false
    };
  } catch (err) {
    return {
      message: () => err.message,
      pass: this.isNot
    };
  }
}

async function toHaveSelectedValue(received, expected) {
  try {
    if (await (0, _utils.isSelectElement)(received)) {
      const value = await received.getAttribute('value');
      return Object.is(value, expected) ? {
        actual: value,
        message: () => this.utils.matcherHint('.not.toHaveSelectedValue') + '\n\n' + 'Expected value to not be (using Object.is):\n' + `  ${this.utils.printExpected(expected)}\n` + 'Received:\n' + `  ${this.utils.printReceived(value)}`,
        pass: true
      } : {
        actual: value,
        message: () => this.utils.matcherHint('.toHaveSelectedValue') + '\n\n' + 'Expected value to be (using Object.is):\n' + `  ${this.utils.printExpected(expected)}\n` + 'Received:\n' + `  ${this.utils.printReceived(value)}`,
        pass: false
      };
    }
  } catch (err) {
    return {
      message: () => err.message,
      pass: this.isNot
    };
  }
}

async function toHaveValue(received, expected) {
  try {
    if ((0, _utils.isWebElement)(received)) {
      const value = await received.getAttribute('value');
      return Object.is(value, expected) ? {
        actual: value,
        message: () => this.utils.matcherHint('.not.toHaveValue') + '\n\n' + 'Expected value to not be (using Object.is):\n' + `  ${this.utils.printExpected(expected)}\n` + 'Received:\n' + `  ${this.utils.printReceived(value)}`,
        pass: true
      } : {
        actual: value,
        message: () => this.utils.matcherHint('.toHaveValue') + '\n\n' + 'Expected value to be (using Object.is):\n' + `  ${this.utils.printExpected(expected)}\n` + 'Received:\n' + `  ${this.utils.printReceived(value)}`,
        pass: false
      };
    }
  } catch (err) {
    return {
      message: () => err.message,
      pass: this.isNot
    };
  }
}

async function toHaveText(received, expected) {
  try {
    if ((0, _utils.isWebElement)(received)) {
      const value = await received.getText();
      return Object.is(value, expected) ? {
        actual: value,
        message: () => this.utils.matcherHint('.not.toHaveText') + '\n\n' + 'Expected value to not be (using Object.is):\n' + `  ${this.utils.printExpected(expected)}\n` + 'Received:\n' + `  ${this.utils.printReceived(value)}`,
        pass: true
      } : {
        actual: value,
        message: () => this.utils.matcherHint('.toHaveText') + '\n\n' + 'Expected value to be (using Object.is):\n' + `  ${this.utils.printExpected(expected)}\n` + 'Received:\n' + `  ${this.utils.printReceived(value)}`,
        pass: false
      };
    }
  } catch (err) {
    return {
      message: () => err.message,
      pass: this.isNot
    };
  }
}

exports.default = {
  toBePresent,
  toBeChecked,
  toBeEditable,
  toHaveSelectedValue,
  toHaveValue,
  toHaveText
};